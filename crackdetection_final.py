# -*- coding: utf-8 -*-
"""crackdetection-final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HlBrW1wa_4uwljgGr6E3iYljVSYPXTmR

## 1)Importing the required libraries
"""

import os
import numpy as np
import tensorflow as tf
import keras
from sklearn.utils import resample
from keras.models import Model
from keras.layers import Dense
from keras import optimizers
#from keras.preprocessing.image import ImageDataGenerator #Original line
from tensorflow.keras.preprocessing.image import ImageDataGenerator #Updated line
from keras.applications.vgg16 import VGG16,preprocess_input
from tensorflow.keras.optimizers import SGD
from keras.callbacks import ModelCheckpoint, EarlyStopping
from tensorflow.keras.preprocessing import image
from sklearn.metrics import precision_recall_fscore_support, accuracy_score,confusion_matrix

"""## 2) Importing the dataset"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("xinzone/surface-crack")

import os
if os.path.exists("/kaggle/input/surface-crack/train"):
    print("Directory exists")
else:
    print("Directory does not exist")

training_data_gen = ImageDataGenerator()
traindata = training_data_gen.flow_from_directory(directory=f"{path}/train", target_size=(224,224))

validation_data_gen = ImageDataGenerator()
validdata = validation_data_gen.flow_from_directory(directory=f"{path}/valid", target_size=(224,224))

"""## 3)Defining the functions used

label(x) a function which is used to create the list yreal, which has true class values of testset images

pred(x) , a function which is used to determine class of the image .It takes in the output of last dense layer of our model and returns the class it belongs to.

test(L,path,images), given a list L and path under which the images are present, will append the predicted classes of those images to L
"""

def label(x):
    if(x<100):
        #First 100 are crack-negative in test set so Yreal is 0
        return 0
    else:
        #Next 100 are crack-positive in test set so Yreal is 1
        return 1
def pred(x):
    if(x[0]>=x[1]):
        return 0
    else:
        return 1
def test(L, path):
    """
    Predicts the class of images in the given path and appends the results to L.

    Args:
        L (list): List to store the predicted classes.
        path (str): Path to the directory containing images.
    """
    for item in os.listdir(path):
        item_path = os.path.join(path, item)
        # Check if the item is a file before processing
        if os.path.isfile(item_path):
            img = image.load_img(item_path, target_size=(224, 224))
            img_array = image.img_to_array(img)
            img_batch = np.expand_dims(img_array, axis=0)
            img_preprocessed = preprocess_input(img_batch)
            prediction = model.predict(img_preprocessed)
            L.append(pred(prediction[0]))
    #Added a print statement to see the content of the item_path
    print(f"item_path: {item_path}")

"""## 4)Defining the model

Model structure:

Inputimage(224 x 224 pixels rgb image)->VGG16->Dense(128 nodes)->Dense_output(2 nodes)
"""

from keras.applications.vgg16 import VGG16
from keras.layers import Dense
from keras.models import Model
from tensorflow.keras.optimizers import SGD
from keras.callbacks import ModelCheckpoint, EarlyStopping

vgg = VGG16(weights='imagenet', include_top=True)
X = vgg.layers[-2].output
X = Dense(128, activation='relu')(X)
predictions = Dense(2, activation="softmax")(X)
model = Model(inputs=vgg.input, outputs=predictions)

# Corrected filename for saving weights:
checkpointname = "vgg16_final.weights.h5"

checkpoint = ModelCheckpoint(checkpointname,
                             monitor='val_acc',
                             verbose=1,
                             save_best_only=True,
                             save_weights_only=False,
                             mode='auto',
                             save_freq='epoch')

early = EarlyStopping(monitor='val_acc',
                      min_delta=0,
                      patience=40,
                      verbose=1,
                      mode='auto')

"""## 5)Training the model

We are training the model at a learning rate of 1e-4 over 100 epochs each iteration. we are training using training data , validating using validation data. The model gets saved after every iteration and predicts for the testset. when a testset accuracy of over 97% is achieved we stop and finalize our model.
"""

yreal=[label(x) for x in range(0,200)]
# Updated paths to include 'test' directory
negpath=f"{path}/test/Negative"
pospath=f"{path}/test/Positive"

# Define EarlyStopping with mode='max' outside the loop
early = EarlyStopping(monitor='val_acc', min_delta=0, patience=40, verbose=1, mode='max')

# Define the number of iterations for the training loop
n_iterations = 10  # You can change this to your desired number of iterations

for i in range(n_iterations):
    ypred=[]
    print("\n\nIteration number: ",i,"\n\n")
    # Replace 'lr' with 'learning_rate' in the SGD optimizer initialization
    model.compile(loss = "categorical_crossentropy", optimizer = SGD(learning_rate=0.0001), metrics=["accuracy"])
    # Replace 'fit_generator' with 'fit' and remove unnecessary parameters
    model.fit(traindata, steps_per_epoch= 2, epochs= 100, validation_data= validdata, validation_steps=1, callbacks=[checkpoint,early])

    # Removed redundant EarlyStopping instantiation

    model.save_weights(checkpointname)
    test(ypred,negpath)
    test(ypred,pospath)
    precision, recall, f1_score, _ = precision_recall_fscore_support(yreal, ypred)
    avg_pre=(precision[0]+precision[1])/2
    acc = accuracy_score(yreal, ypred)
    print("\n Testing Accuracy is: ",acc)
    if(acc>0.97):
        cm=confusion_matrix(yreal,ypred)
        print("Model finalised.\nAccuracy: ",acc)
        print("Precision: ",precision)
        print("Recall: ",recall)
        print("F1: ",f1_score)
        print("Confusion matrix: ",cm)
        break

"""## 6)Predictions"""

import os
import numpy as np
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input

predictpath = f"{path}/test"  # Ensure `path` is correctly set

# Get all image files from subdirectories
predict_images = []
for subdir in os.listdir(predictpath):
    item_path = os.path.join(predictpath, subdir)
    if os.path.isdir(item_path):  # Check if it's a directory
        predict_images.append(item_path)  # Append directory path, not individual files

print(f"Found {len(predict_images)} subdirectories: {predict_images}")

# Ensure test function is properly called
predictions = []
for subdir in predict_images:
    test(predictions, subdir)  # Now, `test()` gets the correct directory path

print(f"Predictions after test(): {predictions}")

# Validate predictions length
total_images = sum(len(os.listdir(subdir)) for subdir in predict_images)
if len(predictions) != total_images:
    print("Error: Number of predictions does not match the number of images!")

# Display results
img_counter = 0
for subdir in predict_images:
    for file in os.listdir(subdir):
        if file.lower().endswith(('.png', '.jpg', '.jpeg')):
            statement = " Crack is present." if predictions[img_counter] == 1 else " No sign of cracks."
            print(file + statement)
            img_counter += 1

import os
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.vgg16 import preprocess_input
import random

# Ensure model is loaded
# model = ... (Load your trained model here)

# Define prediction function
def pred(value):
    return 1 if value[0] > 0.5 else 0  # Convert probability to binary

# Define test function for a single image
def test_single_image(img_path):
    img = image.load_img(img_path, target_size=(224, 224))
    img_array = image.img_to_array(img)
    img_batch = np.expand_dims(img_array, axis=0)
    img_preprocessed = preprocess_input(img_batch)
    prediction = model.predict(img_preprocessed)
    return pred(prediction.flatten())

# Define path
predictpath = f"{path}/test"

# Get all image files from subdirectories
predict_images = []
for subdir in os.listdir(predictpath):
    subdir_path = os.path.join(predictpath, subdir)
    if os.path.isdir(subdir_path):
        for file in os.listdir(subdir_path):
            if file.lower().endswith(('.png', '.jpg', '.jpeg')):
                predict_images.append(os.path.join(subdir_path, file))

print(f"Found {len(predict_images)} images.")

# Select exactly 10 images randomly
selected_images = random.sample(predict_images, min(10, len(predict_images)))
print(f"Selected {len(selected_images)} images for prediction.")

# Predict only the selected 10 images
predictions = [test_single_image(img_path) for img_path in selected_images]
print(f"Predictions: {predictions}")

# Display images in two neat rows (5 per row)
num_images = len(selected_images)
cols = 5  # Display 5 per row
rows = 2 if num_images > 5 else 1  # Ensure a clean two-row layout

fig, axes = plt.subplots(rows, cols, figsize=(20, 8))  # Wider layout for clarity
axes = axes.flatten() if rows > 1 else [axes]  # Flatten for consistency

for i, ax in enumerate(axes):
    if i < num_images:
        img_path = selected_images[i]
        img = image.load_img(img_path, target_size=(224, 224))

        ax.imshow(img)
        ax.axis("off")  # Hide axis for cleaner display

        # Label with clear, elegant font
        result = "No Crack" if predictions[i] == 1 else "Crack Present"
        ax.set_title(result, fontsize=18, fontweight='bold',
                     color="green" if predictions[i] == 1 else "red")
    else:
        ax.axis("off")  # Hide any extra empty slots

plt.tight_layout(pad=2.0)  # Clean spacing
plt.show()

"""## 7)Testing evaluation"""

ypred=[]
test(ypred,negpath)
test(ypred,pospath)
precision, recall, f1_score, _ = precision_recall_fscore_support(yreal, ypred)
avg_pre=(precision[0]+precision[1])/2
acc = accuracy_score(yreal, ypred)
cm=confusion_matrix(yreal,ypred)
print("Testing Accuracy is: ",acc)
print("Precision: ",precision)
print("Recall: ",recall)
print("F1: ",f1_score)
print("Confusion matrix:\n",cm)

